{"version":3,"file":"race.service.spec.js","sourceRoot":"","sources":["race.service.spec.ts"],"names":[],"mappings":";AAAA,wBAMO,uBAAuB,CAAC,CAAA;AAC/B,qBAAwB,eAAe,CAAC,CAAA;AACxC,qBAAmF,eAAe,CAAC,CAAA;AACnG,wBAA4B,uBAAuB,CAAC,CAAA;AACpD,QAAO,wBAAwB,CAAC,CAAA;AAEhC,6BAA4B,gBAAgB,CAAC,CAAA;AAE7C,kBAAQ,CAAC,qBAAqB,EAAE;IAE9B,6BAAmB,CAAC,cAAM,OAAA;QACxB,qBAAW;QACX,yBAAkB;QAClB,cAAO,CAAC,WAAI,EAAE;YACZ,UAAU,EAAE,UAAC,OAAO,EAAE,cAAc,IAAK,OAAA,IAAI,WAAI,CAAC,OAAO,EAAE,cAAc,CAAC,EAAjC,CAAiC;YAC1E,IAAI,EAAE,CAAC,qBAAW,EAAE,yBAAkB,CAAC;SACxC,CAAC;QACF,0BAAW;KACZ,EARyB,CAQzB,CAAC,CAAC;IAEH,YAAE,CAAC,wCAAwC,EAAE,gBAAM,CAAC,CAAC,0BAAW,EAAE,qBAAW,CAAC,EAC5E,UAAC,OAAO,EAAE,WAAW;QACnB,gBAAgB;QAChB,IAAI,cAAc,GAAG,CAAC,EAAC,IAAI,EAAE,OAAO,EAAC,EAAE,EAAC,IAAI,EAAE,OAAO,EAAC,EAAE,EAAC,IAAI,EAAE,MAAM,EAAC,CAAC,CAAC;QACxE,IAAI,QAAQ,GAAG,IAAI,eAAQ,CAAC,IAAI,sBAAe,CAAC,EAAC,IAAI,EAAE,cAAc,EAAC,CAAC,CAAC,CAAC;QACzE,iEAAiE;QACjE,WAAW,CAAC,WAAW,CAAC,SAAS,CAAC,UAAA,UAAU;YAC1C,gBAAM,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC;iBAC3B,IAAI,CAAC,2DAA2D,CAAC,CAAC;YACrE,gBAAM,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,oBAAa,CAAC,GAAG,CAAC,CAAC;YAC1D,UAAU,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;QACnC,CAAC,CAAC,CAAC;QAEH,OAAO,CAAC,IAAI,EAAE,CAAC,SAAS,CAAC,UAAA,KAAK;YAC5B,gBAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAC/B,CAAC,CAAC,CAAC;IACL,CAAC,CACF,CAAC,CAAC;AAEL,CAAC,CAAC,CAAC","sourcesContent":["import {\n  beforeEachProviders,\n  it,\n  describe,\n  expect,\n  inject\n} from '@angular/core/testing';\nimport { provide } from '@angular/core';\nimport { Http, BaseRequestOptions, Response, ResponseOptions, RequestMethod } from '@angular/http';\nimport { MockBackend } from '@angular/http/testing';\nimport 'rxjs/add/observable/of';\n\nimport { RaceService } from './race.service';\n\ndescribe('RaceService Service', () => {\n\n  beforeEachProviders(() => [\n    MockBackend,\n    BaseRequestOptions,\n    provide(Http, {\n      useFactory: (backend, defaultOptions) => new Http(backend, defaultOptions),\n      deps: [MockBackend, BaseRequestOptions]\n    }),\n    RaceService\n  ]);\n\n  it('should return an Observable of 3 races', inject([RaceService, MockBackend],\n    (service, mockBackend) => {\n      // fake response\n      let hardcodedRaces = [{name: 'Paris'}, {name: 'Tokyo'}, {name: 'Lyon'}];\n      let response = new Response(new ResponseOptions({body: hardcodedRaces}));\n      // return the response if we have a connection to the MockBackend\n      mockBackend.connections.subscribe(connection => {\n        expect(connection.request.url)\n          .toBe('http://ponyracer.ninja-squad.com/api/races?status=PENDING');\n        expect(connection.request.method).toBe(RequestMethod.Get);\n        connection.mockRespond(response);\n      });\n\n      service.list().subscribe(races => {\n        expect(races.length).toBe(3);\n      });\n    }\n  ));\n\n});\n"]}